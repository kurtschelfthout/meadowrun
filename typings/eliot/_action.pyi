from typing import Any, Callable, Iterable, TypeVar, overload
from _typeshed import Incomplete
from collections.abc import Generator
from pyrsistent import PClass

ACTION_STATUS_FIELD: str
ACTION_TYPE_FIELD: str
STARTED_STATUS: str
SUCCEEDED_STATUS: str
FAILED_STATUS: str
VALID_STATUSES: Incomplete

def current_action() -> Action: ...

class TaskLevel:
    def __init__(self, level) -> None: ...
    def as_list(self): ...
    @property
    def level(self): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    @classmethod
    def fromString(cls, string): ...
    def toString(self): ...
    def next_sibling(self): ...
    def child(self): ...
    def parent(self): ...
    def is_sibling_of(self, task_level): ...
    from_string: Incomplete
    to_string: Incomplete

class Action:
    def __init__(
        self,
        logger,
        task_uuid,
        task_level,
        action_type,
        serializers: Incomplete | None = ...,
    ) -> None: ...
    @property
    def task_uuid(self): ...
    def serialize_task_id(self) -> bytes: ...
    @classmethod
    def continue_task(
        cls,
        logger: Incomplete | None = ...,
        task_id=...,
        *,
        action_type: str = ...,
        _serializers: Incomplete | None = ...,
        **fields,
    ): ...
    serializeTaskId: Incomplete
    continueTask: Incomplete
    def finish(self, exception: Incomplete | None = ...) -> None: ...
    def child(self, logger, action_type, serializers: Incomplete | None = ...): ...
    def run(self, f, *args, **kwargs): ...
    def addSuccessFields(self, **fields) -> None: ...
    add_success_fields: Incomplete
    def context(self) -> Generator[Incomplete, None, None]: ...
    def __enter__(self) -> "Action": ...
    def __exit__(self, type, exception, traceback) -> None: ...
    def log(self, message_type, **fields) -> None: ...

class WrongTask(Exception):
    def __init__(self, action, message) -> None: ...

class WrongTaskLevel(Exception):
    def __init__(self, action, message) -> None: ...

class WrongActionType(Exception):
    def __init__(self, action, message) -> None: ...

class InvalidStatus(Exception):
    def __init__(self, action, message) -> None: ...

class DuplicateChild(Exception):
    def __init__(self, action, message) -> None: ...

class InvalidStartMessage(Exception):
    def __init__(self, message, reason) -> None: ...
    @classmethod
    def wrong_status(cls, message): ...
    @classmethod
    def wrong_task_level(cls, message): ...

class WrittenAction(PClass):
    start_message: Incomplete
    end_message: Incomplete
    task_level: Incomplete
    task_uuid: Incomplete
    @classmethod
    def from_messages(
        cls,
        start_message: Incomplete | None = ...,
        children=...,
        end_message: Incomplete | None = ...,
    ): ...
    @property
    def action_type(self): ...
    @property
    def status(self): ...
    @property
    def start_time(self): ...
    @property
    def end_time(self): ...
    @property
    def exception(self): ...
    @property
    def reason(self): ...
    @property
    def children(self): ...

def start_action(
    logger: Incomplete | None = ...,
    action_type: str = ...,
    _serializers: Incomplete | None = ...,
    **fields,
) -> Action: ...
def startTask(
    logger: Incomplete | None = ...,
    action_type: str = ...,
    _serializers: Incomplete | None = ...,
    **fields,
) -> Action: ...

class TooManyCalls(Exception): ...

def preserve_context(f): ...

F = TypeVar("F", bound=Callable[..., Any])

@overload
def log_call(wrapped_function: F = ...) -> F: ...
@overload
def log_call(
    *,
    action_type: str | None = ...,
    include_args: Iterable[str] | None = ...,
    include_result: bool = ...,
) -> Callable[[F], F]: ...

# def log_call(
#     wrapped_function: F = ...,
#     action_type: str | None = ...,
#     include_args: Iterable[str] | None = ...,
#     include_result: bool = ...,
# ) -> Union[F, Callable[[F], F]]: ...
def log_message(message_type, **fields) -> None: ...
